#include <iostream>
#include <unistd.h>
#include <sys/wait.h>
#include <vector>
#include <sstream>
#include <cstring>
#include <ncurses.h>


void print_error(const std::string &msg) {
    std::cout << msg << std::endl << strerror(errno) << std::flush << std::endl;
}

void launchActivity(const std::vector<char *> &args1, bool out_flag = true) {
    if (args1[0] == nullptr) {
        print_error("first argument is nullptr");
        return;
    }
    pid_t ret = fork();
    if (ret < 0) {
        if (out_flag)
            print_error("Unable to fork() =(");
    } else if (ret == 0) {
        if (execvp(args1[0], args1.data()) == -1) {
            if (out_flag)
                print_error("Execution error");
            exit(-1);
        }
        exit(0);
    } else {
        int exitStatus;
        if (waitpid(ret, &exitStatus, 0) == -1) {
            if (out_flag)
                print_error("Error during execution");
        } else {
            if (out_flag) {
                if (exitStatus != 0) {
                    print_error("Exit status is not 0");
                }
                std::cout << "Programme exited with exit code: " << exitStatus << std::endl;
            }
        }
    }
}

//void launcher(const std::vector<const char *> &args1, bool out_flag = true) {
//    std::vector<char *> arg_real;
//    arg_real.reserve(args1.size());
//    for (const char *chars : args1) {
//        arg_real.push_back(const_cast<char *>(chars));
//    }
//    launchActivity(arg_real, out_flag);
//}

std::vector<char *> parseArgs(const std::string &stringArgs) {
    std::stringstream stream(stringArgs);
    std::string arg;
    std::vector<char *> ans;
    while (stream >> arg) {
        char *str = new char[arg.size() + 1];
        memcpy(str, arg.c_str(), arg.size() * sizeof(char));
        str[arg.size()] = '\0';
        ans.push_back(str);
    }
    ans.push_back(nullptr);
    return ans;
}

void hello() {
    std::cout << "~/";
    std::cout.flush();
}

std::string genstring(size_t size) {
    std::string empty_space;
    empty_space.reserve(size + 30);
    for (size_t s = 0; s < size + 30; ++s) {
        empty_space += " ";
    }
    return empty_space;
}

void cleanscr(size_t size) {
    std::string empty_space = genstring(size);
    std::cout << '\r' << empty_space << '\r';
    hello();
}

class controller {
public:
//    controller() {
//        launcher({"stty", "-echo"}, false);
//        launcher({"stty", "raw"}, false);
//        launcher({"setterm", "-cursor", "off"}, false);
//
//    }
//
//    ~controller() {
//        launcher({"stty", "echo"}, false);
//        launcher({"stty", "cooked"}, false);
//        launch({"setterm", "-cursor", "on"}, false);
//    }

    controller() {
        launchActivity({const_cast<char *>("stty"), const_cast<char *>("-echo")}, false);
        launchActivity({const_cast<char *>("stty"), const_cast<char *>("raw")}, false);
        launchActivity({const_cast<char *>("setterm"), const_cast<char *>("-cursor"), const_cast<char *>("off")},
                       false);

    }

    ~controller() {
        launchActivity({const_cast<char *>("stty"), const_cast<char *>("echo")}, false);
        launchActivity({const_cast<char *>("stty"), const_cast<char *>("cooked")}, false);
        launchActivity({const_cast<char *>("setterm"), const_cast<char *>("-cursor"), const_cast<char *>("on")}, false);
    }
};

int main(int args, char *argv[]) {
    const std::string up = {27, 91, 65};
    const std::string down = {27, 91, 66};
    const std::string right = {27, 91, 67};
    const std::string left = {27, 91, 68};
    bool exit_flag = false;

    size_t cursor_posititon = 0;

    std::vector<std::string> queue = {""};
    size_t queue_position = 1;

    while (true) {
        std::string inputString;
        cleanscr(inputString.length());
        std::cout << inputString << std::flush;
        {
            controller controller1{};
            cursor_posititon = 0;
            while (true) {
///                std::cout << cursor_posititon << std::endl;
//                std::cout << inputString.length() << std::endl;
                cleanscr(inputString.length());
                std::cout << inputString << std::flush;
                inputString.insert(inputString.begin() + cursor_posititon, getchar());
//                cleanscr(inputString.length());
//                std::cout << inputString << std::flush;

                if (cursor_posititon >= 2) {
                    if (inputString.substr(cursor_posititon - 2, 3) == up) {
                        cleanscr(inputString.length());
                        if (queue_position != 0) {
                            cleanscr(inputString.length());
                            inputString = queue[--queue_position];
                            cursor_posititon = inputString.length();
                            continue;
                        }
                        inputString.erase(inputString.begin() + cursor_posititon);
                        inputString.erase(inputString.begin() + cursor_posititon - 1);
                        inputString.erase(inputString.begin() + cursor_posititon - 2);
                        cursor_posititon -= 2;
                        continue;
                    }
                    if (inputString.substr(cursor_posititon - 2, 3) == down) {
                        cleanscr(inputString.length());
                        if (queue_position < queue.size() - 1) {
                            cleanscr(inputString.length());
                            inputString = queue[++queue_position];
                            cursor_posititon = inputString.length();
                            continue;
                        }
                        if (queue_position == queue.size() - 1){
                            inputString = "";
                            cursor_posititon = 0;
                            continue;
                        }
                        inputString.erase(inputString.begin() + cursor_posititon);
                        inputString.erase(inputString.begin() + cursor_posititon - 1);
                        inputString.erase(inputString.begin() + cursor_posititon - 2);
                        cursor_posititon -= 2;
                        continue;
                    }
                    if (inputString.substr(cursor_posititon - 2, 3) == right) {
                        inputString.erase(inputString.begin() + cursor_posititon);
                        inputString.erase(inputString.begin() + cursor_posititon - 1);
                        inputString.erase(inputString.begin() + cursor_posititon - 2);
                        cursor_posititon -= 2;
                        if (cursor_posititon < inputString.length()) {
                            ++cursor_posititon;
                        }
                        continue;
                    }
                    if (inputString.substr(cursor_posititon - 2, 3) == left) {
//                        std::cout << std::endl << "\r" << inputString << std::endl;
                        inputString.erase(inputString.begin() + cursor_posititon);
                        inputString.erase(inputString.begin() + cursor_posititon - 1);
                        inputString.erase(inputString.begin() + cursor_posititon - 2);
                        cursor_posititon -= 2;
                        if (cursor_posititon > 0) {
                            --cursor_posititon;
                        }
                        continue;
                    }
                }
                if (inputString[cursor_posititon] == 127) {
                    inputString.erase(inputString.begin() + cursor_posititon);
                    if (inputString.length() >= 1) {
                        if (cursor_posititon != 0)
                            --cursor_posititon;
                        inputString.erase(inputString.begin() + cursor_posititon);
//                        inputString.pop_back();
                    }
                    continue;
                }
                if (inputString[cursor_posititon] == 13) {
                    inputString.erase(inputString.begin() + cursor_posititon);
                    break;
                }
                if (inputString[cursor_posititon] == 3) {
                    std::cout << std::endl << std::endl;
                    std::cout << "\rKeyboard interrupt.." << std::flush;
                    std::cout << "exiting..." << std::flush;
                    exit_flag = true;
                    break;
                }
                ++cursor_posititon;
            }

            std::cout << "\r\n" << std::flush;
        }

        if (exit_flag) {
            return 0;
        }

        queue.push_back(inputString);
        ++queue_position;

        if (inputString == "exit") {
            std::cout << "\rexiting..." << std::endl;
            exit(0);
        }
        auto args1 = parseArgs(inputString);

        launchActivity(args1);

        for (char *str : args1) {
            delete[] str;
        }

        std::cout << std::flush;
//        hello();

    }
}
